<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simple CapCut Lite + Export + Mirror</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  video { max-width: 100%; margin-bottom: 10px; }
  #timeline { border: 1px solid #ccc; padding: 10px; margin-top: 10px; }
  .clip {
    background: #007bff;
    color: white;
    padding: 5px;
    margin: 2px;
    cursor: pointer;
    display: inline-block;
    position: relative;
  }
  .mirror-btn {
    background: #28a745;
    border: none;
    color: white;
    font-size: 10px;
    padding: 2px 5px;
    cursor: pointer;
    position: absolute;
    top: 2px;
    right: 2px;
  }
  .mirrored {
    background: #ffc107 !important;
  }
  #projectSaveLoad { margin-top: 20px; }
  #exportBtn { margin-top: 15px; }
</style>
</head>
<body>

<h2>Simple CapCut Lite - Local + Export + Mirror</h2>

<input type="file" id="videoInput" accept="video/*" multiple />
<br />

<video id="videoPlayer" controls></video>
<br />

<button id="trimStartBtn">Set Trim Start</button>
<button id="trimEndBtn">Set Trim End</button>
<button id="addClipBtn">Add Clip to Timeline</button>

<h3>Timeline (click "Mirror" to toggle horizontal flip)</h3>
<div id="timeline"></div>

<div id="projectSaveLoad">
  <button id="saveProjectBtn">Save Project</button>
  <input type="file" id="loadProjectInput" />
</div>

<button id="exportBtn">Export Video</button>
<div id="exportStatus"></div>

<script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.7/dist/ffmpeg.min.js"></script>
<script>
  const { createFFmpeg, fetchFile } = FFmpeg;
  const ffmpeg = createFFmpeg({ log: true });

  const videoInput = document.getElementById('videoInput');
  const videoPlayer = document.getElementById('videoPlayer');
  const trimStartBtn = document.getElementById('trimStartBtn');
  const trimEndBtn = document.getElementById('trimEndBtn');
  const addClipBtn = document.getElementById('addClipBtn');
  const timeline = document.getElementById('timeline');
  const saveProjectBtn = document.getElementById('saveProjectBtn');
  const loadProjectInput = document.getElementById('loadProjectInput');
  const exportBtn = document.getElementById('exportBtn');
  const exportStatus = document.getElementById('exportStatus');

  let loadedVideos = []; // {file: File, url: string, name: string}
  let currentVideoIndex = 0;

  let trimStart = 0;
  let trimEnd = 0;

  // timelineClips now also stores mirror state: {videoIndex, start, end, mirror}
  let timelineClips = [];

  videoInput.addEventListener('change', (e) => {
    loadedVideos = [];
    timelineClips = [];
    timeline.innerHTML = '';
    const files = Array.from(e.target.files);
    files.forEach(file => {
      const url = URL.createObjectURL(file);
      loadedVideos.push({ file, url, name: file.name });
    });
    if(loadedVideos.length > 0){
      currentVideoIndex = 0;
      loadVideo(loadedVideos[0].url);
    }
  });

  function loadVideo(url){
    videoPlayer.src = url;
    trimStart = 0;
    trimEnd = 0;
  }

  trimStartBtn.onclick = () => {
    trimStart = videoPlayer.currentTime;
    alert(`Trim start set to ${trimStart.toFixed(2)}s`);
  };

  trimEndBtn.onclick = () => {
    trimEnd = videoPlayer.currentTime;
    if(trimEnd <= trimStart){
      alert('Trim end must be greater than trim start!');
      trimEnd = 0;
      return;
    }
    alert(`Trim end set to ${trimEnd.toFixed(2)}s`);
  };

  addClipBtn.onclick = () => {
    if(trimEnd === 0) trimEnd = videoPlayer.duration;
    if(trimEnd <= trimStart){
      alert('Please set valid trim start and end!');
      return;
    }
    timelineClips.push({ videoIndex: currentVideoIndex, start: trimStart, end: trimEnd, mirror: false });
    renderTimeline();
    trimStart = 0;
    trimEnd = 0;
  };

  function renderTimeline(){
    timeline.innerHTML = '';
    timelineClips.forEach((clip, idx) => {
      const clipDiv = document.createElement('div');
      clipDiv.className = 'clip' + (clip.mirror ? ' mirrored' : '');
      const vidName = loadedVideos[clip.videoIndex].name;
      clipDiv.textContent = `${vidName}: ${clip.start.toFixed(2)}s - ${clip.end.toFixed(2)}s`;

      // Mirror toggle button
      const mirrorBtn = document.createElement('button');
      mirrorBtn.className = 'mirror-btn';
      mirrorBtn.textContent = clip.mirror ? 'Mirrored' : 'Mirror';
      mirrorBtn.onclick = (e) => {
        e.stopPropagation();
        timelineClips[idx].mirror = !timelineClips[idx].mirror;
        renderTimeline();
      };
      clipDiv.appendChild(mirrorBtn);

      timeline.appendChild(clipDiv);
    });
  }

  // Save project to JSON file
  saveProjectBtn.onclick = () => {
    if(loadedVideos.length === 0){
      alert('Load videos first!');
      return;
    }
    const projectData = {
      videos: loadedVideos.map(v => ({ name: v.name })),
      clips: timelineClips
    };
    const jsonStr = JSON.stringify(projectData, null, 2);
    const blob = new Blob([jsonStr], {type: "application/json"});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = "capcut_project.json";
    a.click();
  };

  // Load project JSON file
  loadProjectInput.onchange = (e) => {
    const file = e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = function(evt){
      try {
        const data = JSON.parse(evt.target.result);
        if(!data.videos || !data.clips){
          alert('Invalid project file');
          return;
        }
        alert('Project loaded. Please load videos again matching the original filenames.');
        timelineClips = data.clips;
        renderTimeline();
      } catch(e) {
        alert('Error parsing project file');
      }
    };
    reader.readAsText(file);
  };

  // Export function with mirror support
  exportBtn.onclick = async () => {
    if(timelineClips.length === 0){
      alert('Add clips to timeline first!');
      return;
    }

    exportStatus.textContent = 'Loading FFmpeg... (this may take a while)';
    if(!ffmpeg.isLoaded()) {
      await ffmpeg.load();
    }

    exportStatus.textContent = 'Preparing files...';

    // Write all videos to FFmpeg FS
    for(let i=0; i<loadedVideos.length; i++){
      const file = loadedVideos[i].file;
      ffmpeg.FS('writeFile', file.name, await fetchFile(file));
    }

    let trimmedFiles = [];
    for(let i=0; i<timelineClips.length; i++){
      const clip = timelineClips[i];
      const inputName = loadedVideos[clip.videoIndex].name;
      const outName = `clip${i}.mp4`;
      trimmedFiles.push(outName);

      const args = [
        '-i', inputName,
        '-ss', `${clip.start}`,
        '-to', `${clip.end}`
      ];

      if(clip.mirror) {
        // Add horizontal flip filter and re-encode (required when filter used)
        args.push(
          '-vf', 'hflip',
          '-c:v', 'libx264',
          '-preset', 'fast',
          '-c:a', 'copy'
        );
      } else {
        // Just copy streams (fast trim)
        args.push('-c', 'copy');
      }

      args.push(outName);

      exportStatus.textContent = `Processing clip ${i+1} / ${timelineClips.length} ${clip.mirror ? '(mirrored)' : ''}`;

      await ffmpeg.run(...args);
    }

    // Create concat list file for ffmpeg
    let concatFileContent = trimmedFiles.map(f => `file '${f}'`).join('\n');
    ffmpeg.FS('writeFile', 'concat_list.txt', concatFileContent);

    exportStatus.textContent = 'Merging clips...';

    // Run concat command to merge all clips
    await ffmpeg.run(
      '-f', 'concat',
      '-safe', '0',
      '-i', 'concat_list.txt',
      '-c', 'copy',
      'output.mp4'
    );

    exportStatus.textContent = 'Export finished! Preparing download...';

    const data = ffmpeg.FS('readFile', 'output.mp4');

    const videoBlob = new Blob([data.buffer], { type: 'video/mp4' });
    const url = URL.createObjectURL(videoBlob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'exported_video.mp4';
    a.click();

    exportStatus.textContent = 'Done! Your video is downloaded.';
  };
</script>

</body>
</html>
